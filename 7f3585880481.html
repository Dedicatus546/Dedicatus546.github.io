<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">


  <link rel="apple-touch-icon" href="/other/favicon.svg">
  <link rel="icon" type="image/svg+xml" href="/other/favicon.svg">
  <link rel="mask-icon" href="/other/favicon.svg" color="#222">

  <link rel="manifest" href="/other/mainfest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"prohibitorum.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"T3MJ56EZKX","apiKey":"d231b9edc85683ea50e37ff0bdc95d43","indexName":"blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言RxJS 源码解读之 Scheduler 。">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJS 源码解读之 Scheduler">
<meta property="og:url" content="https://prohibitorum.top/7f3585880481">
<meta property="og:site_name" content="恋の歌">
<meta property="og:description" content="前言RxJS 源码解读之 Scheduler 。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/Dedicatus546/image@main/2023/10/27/202310271142144.avif">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/Dedicatus546/image@main/2023/10/30/202310300947615.avif">
<meta property="og:image" content="https://user-images.githubusercontent.com/48575405/279329977-5427887c-3aab-4594-aee3-b6e709336b8d.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/48575405/279330102-0745fb8d-be07-44c3-a452-2699e161630d.png">
<meta property="article:published_time" content="2023-10-26T18:26:59.000Z">
<meta property="article:modified_time" content="2023-11-04T01:12:59.000Z">
<meta property="article:author" content="Dedicatus545">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="RxJS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fastly.jsdelivr.net/gh/Dedicatus546/image@main/2023/10/27/202310271142144.avif">


<link rel="canonical" href="https://prohibitorum.top/7f3585880481.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://prohibitorum.top/7f3585880481","path":"7f3585880481.html","title":"RxJS 源码解读之 Scheduler"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RxJS 源码解读之 Scheduler | 恋の歌</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-TDBJV1DQ49"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-TDBJV1DQ49","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">恋の歌</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">koi-no-uta</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%A3%E6%96%87"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81"><span class="nav-number">2.2.</span> <span class="nav-text">源码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scheduler-%E5%92%8C-Action"><span class="nav-number">2.2.1.</span> <span class="nav-text">Scheduler 和 Action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncScheduler-%E5%92%8C-AsyncAction"><span class="nav-number">2.2.2.</span> <span class="nav-text">AsyncScheduler 和 AsyncAction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsapScheduler-%E5%92%8C-AsapAction"><span class="nav-number">2.2.3.</span> <span class="nav-text">AsapScheduler 和 AsapAction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AnimationFrameScheduler-%E5%92%8C-AnimationFrameAction"><span class="nav-number">2.2.4.</span> <span class="nav-text">AnimationFrameScheduler 和 AnimationFrameAction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QueueScheduler-%E5%92%8C-QueueAction"><span class="nav-number">2.2.5.</span> <span class="nav-text">QueueScheduler 和 QueueAction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scheduler-%E5%92%8C-Observable"><span class="nav-number">2.3.</span> <span class="nav-text">Scheduler 和 Observable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#subscribeOn"><span class="nav-number">2.3.1.</span> <span class="nav-text">subscribeOn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ObserveOn"><span class="nav-number">2.3.2.</span> <span class="nav-text">ObserveOn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E7%AE%A1%E9%81%93"><span class="nav-number">2.3.3.</span> <span class="nav-text">其他操作符和管道</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E8%AE%B0"><span class="nav-number">3.</span> <span class="nav-text">后记</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dedicatus545"
      src="https://avatars.githubusercontent.com/u/48575405?v=4">
  <p class="site-author-name" itemprop="name">Dedicatus545</p>
  <div class="site-description" itemprop="description">Index-Librorum-Prohibitorum</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">192</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Dedicatus546" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dedicatus546" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1607611087@qq.com" title="E-Mail → mailto:1607611087@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" class="cc-opacity" rel="noopener" target="_blank"><img src="https://fastly.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://prohibitorum.top/7f3585880481">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/48575405?v=4">
      <meta itemprop="name" content="Dedicatus545">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恋の歌">
      <meta itemprop="description" content="Index-Librorum-Prohibitorum">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="RxJS 源码解读之 Scheduler | 恋の歌">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RxJS 源码解读之 Scheduler
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-26 18:26:59" itemprop="dateCreated datePublished" datetime="2023-10-26T18:26:59+00:00">2023-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-04 01:12:59" itemprop="dateModified" datetime="2023-11-04T01:12:59+00:00">2023-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RxJS 源码解读之 <code>Scheduler</code> 。</p>
<span id="more"></span>

<p>在前面的文章中，我们讲了 RxJS 核心的几个概念，并且分析了它们源码中的实现。</p>
<p>本文我们讲 RxJS 中另一位维度的东西，它称之为 Scheduler 。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Scheduler ，在英文中的意思为调度器，一听到调度器我们可能就有点害怕了，跟这东西有关的都是让人头疼的东西，比如 Linux 内核中的调度器，用来调度进程。</p>
<p>在 RxJS 中，调度器是一个独立的概念，他其实完全可以单独拎出来使用。 RxJS 的调度器，本质就是决定函数执行的时机。</p>
<p>再简单点讲，它其实就是包装了诸如 <code>setInterval</code> 、 <code>Promise.then</code> 、 <code>requestAnimateFrame</code> 等的 API 。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="Scheduler-和-Action"><a href="#Scheduler-和-Action" class="headerlink" title="Scheduler 和 Action"></a>Scheduler 和 Action</h3><p>在 RxJS 中，调度器有两个核心的基类，一个是 <code>Scheduler</code> 、 一个是 <code>Action</code> 。</p>
<p>这两个基类的实现都非常的简单，源码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Scheduler</span> <span class="keyword">implements</span> <span class="title class_">SchedulerLike</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="attr">now</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span> = dateTimestampProvider.<span class="property">now</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="attr">schedulerActionCtor</span>: <span class="keyword">typeof</span> <span class="title class_">Action</span>, <span class="attr">now</span>: () =&gt; <span class="built_in">number</span> = <span class="title class_">Scheduler</span>.now</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">now</span> = now;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="attr">now</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 核心函数</span></span><br><span class="line">  <span class="keyword">public</span> schedule&lt;T&gt;(<span class="attr">work</span>: <span class="function">(<span class="params"><span class="attr">this</span>: <span class="title class_">SchedulerAction</span>&lt;T&gt;, state?: T</span>) =&gt;</span> <span class="built_in">void</span>, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>, state?: T): <span class="title class_">Subscription</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable language_">this</span>.<span class="property">schedulerActionCtor</span>&lt;T&gt;(<span class="variable language_">this</span>, work).<span class="title function_">schedule</span>(state, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Action</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Subscription</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">scheduler</span>: <span class="title class_">Scheduler</span>, <span class="attr">work</span>: (<span class="variable language_">this</span>: SchedulerAction&lt;T&gt;, state?: T) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 核心函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">schedule</span>(state?: T, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">Subscription</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到 <code>Action</code> 实现了 <code>Subscription</code> ，也就是 <code>Action</code> 应该也有一个取消订阅的操作，这个后面会说到，而 <code>Scheduler</code> 实现了 <code>SchedulerLike</code> 接口，这个接口抽象了类调度器的类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">SchedulerLike</span> <span class="keyword">extends</span> <span class="title class_">TimestampProvider</span> &#123;</span><br><span class="line">  schedule&lt;T&gt;(<span class="attr">work</span>: <span class="function">(<span class="params"><span class="attr">this</span>: <span class="title class_">SchedulerAction</span>&lt;T&gt;, <span class="attr">state</span>: T</span>) =&gt;</span> <span class="built_in">void</span>, <span class="attr">delay</span>: <span class="built_in">number</span>, <span class="attr">state</span>: T): <span class="title class_">Subscription</span>;</span><br><span class="line">  schedule&lt;T&gt;(<span class="attr">work</span>: <span class="function">(<span class="params"><span class="attr">this</span>: <span class="title class_">SchedulerAction</span>&lt;T&gt;, state?: T</span>) =&gt;</span> <span class="built_in">void</span>, <span class="attr">delay</span>: <span class="built_in">number</span>, state?: T): <span class="title class_">Subscription</span>;</span><br><span class="line">  schedule&lt;T&gt;(<span class="attr">work</span>: <span class="function">(<span class="params"><span class="attr">this</span>: <span class="title class_">SchedulerAction</span>&lt;T&gt;, state?: T</span>) =&gt;</span> <span class="built_in">void</span>, delay?: <span class="built_in">number</span>, state?: T): <span class="title class_">Subscription</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">TimestampProvider</span> &#123;</span><br><span class="line">  <span class="title function_">now</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>TimestampProvider</code> 可以先忽略，在 <code>Scheduler</code> 的源码中，基本用不到这个属性。</p>
<p>回到 <code>Scheduler</code> 类，<code>Scheduler</code> 会通过构造函数持有一个 <code>Action</code> 的类（注意，这里是持有一个 <code>Action</code> 类，而不是一个 <code>Action</code> 类的实例），然后在 <code>schedule</code> 中实例化持有的 <code>Action</code> 类， 即代码中的 <code>new this.schedulerActionCtor&lt;T&gt;(this, work)</code> ，接着调用 <code>Action</code> 的 <code>schedule</code> 并返回自身，前面我们说过 <code>Action</code> 继承自 <code>Subscription</code> 。所以我们在通过 <code>Scheduler.prototype.schedule</code> 得到的对象其实就是一个 <code>Action</code> 对象。</p>
<p>我们可以简单地用箭头来描述此时的调用流向：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scheduler.schedule</span><br><span class="line">-&gt; new Action</span><br><span class="line">-&gt; Action.schedule</span><br></pre></td></tr></table></figure>

<p>需要着重注意的是：我们的调度函数（ <code>work</code> ）是保存在 <code>Action</code> 中的，这点很重要。</p>
<p>在 RxJS 中，提供了四种不同的调度器，分别是 <code>asyncScheduler</code> 、 <code>asapScheduler</code> 、 <code>queueScheduler</code> 、 <code>animationFrameScheduler</code> ，需要注意，这些导出的对象已经是类的实例了，可以直接使用，不能通过 <code>new</code> 来调用。比如 <code>asyncScheduler</code> ，它的导出是下面这样子的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> asyncScheduler = <span class="keyword">new</span> <span class="title class_">AsyncScheduler</span>(<span class="title class_">AsyncAction</span>);</span><br></pre></td></tr></table></figure>

<p>其中 <code>AsapScheduler</code> 、 <code>QueueScheduler</code> 和 <code>AnimationFrameScheduler</code> 都是从 <code>AsyncScheduler</code> 派生出来的，所以我们先看一下 <code>AsyncScheduler</code> 的实现。</p>
<h3 id="AsyncScheduler-和-AsyncAction"><a href="#AsyncScheduler-和-AsyncAction" class="headerlink" title="AsyncScheduler 和 AsyncAction"></a>AsyncScheduler 和 AsyncAction</h3><p><code>AsyncScheduler</code> 的实现本质就是包装了 <code>setInterval</code> 。我们先看 <code>AsyncScheduler</code> 的整体实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncScheduler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Scheduler</span> &#123;</span><br><span class="line">  <span class="comment">// 持有的 Action 实例，先不管</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">actions</span>: <span class="title class_">Array</span>&lt;<span class="title class_">AsyncAction</span>&lt;<span class="built_in">any</span>&gt;&gt; = [];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 调度的过程是否在执行中</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">_active</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最近一次调度对应的 id ，可能是 setInterval 、 setInterval 或者 requestAnimationFrame 的返回值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">_scheduled</span>: <span class="title class_">TimerHandle</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 持有 Action 类</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="title class_">SchedulerAction</span>: <span class="keyword">typeof</span> <span class="title class_">Action</span>, <span class="attr">now</span>: () =&gt; <span class="built_in">number</span> = <span class="title class_">Scheduler</span>.now</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="title class_">SchedulerAction</span>, now);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">flush</span>(<span class="attr">action</span>: <span class="title class_">AsyncAction</span>&lt;<span class="built_in">any</span>&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>AsyncScheduler</code> 并没有重写 <code>Scheduler</code> 的 <code>schedule</code> ，所以当我们使用 <code>schedule</code> 的时候还是调用的 <code>Scheduler</code> 的 <code>schedule</code> 实现。 <code>AsyncScheduler</code> 还多了一个 <code>flush</code> 方法，这里我们先不管。</p>
<p>接着我们来看 <code>AsyncAction</code> 的实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Action</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 调度对应的 id ，在这里指 setInterval 返回的值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">id</span>: <span class="title class_">TimerHandle</span> | <span class="literal">undefined</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调度的上下文，通俗点讲就是回调的入参</span></span><br><span class="line">  <span class="keyword">public</span> state?: T;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调度延迟的时间，可以理解为传递给 setInterval 的第二个参数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">delay</span>: <span class="built_in">number</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 是否处于调度过程中</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">pending</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scheduler 为该实例对应的 Scheduler 实例</span></span><br><span class="line">  <span class="comment">// work 为持有的调度函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">protected</span> <span class="attr">scheduler</span>: <span class="title class_">AsyncScheduler</span>, <span class="keyword">protected</span> <span class="attr">work</span>: (<span class="variable language_">this</span>: SchedulerAction&lt;T&gt;, state?: T) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(scheduler, work);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">schedule</span>(state?: T, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">Subscription</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">requestAsyncId</span>(<span class="attr">scheduler</span>: <span class="title class_">AsyncScheduler</span>, _id?: <span class="title class_">TimerHandle</span>, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">TimerHandle</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">recycleAsyncId</span>(<span class="attr">_scheduler</span>: <span class="title class_">AsyncScheduler</span>, id?: <span class="title class_">TimerHandle</span>, <span class="attr">delay</span>: <span class="built_in">number</span> | <span class="literal">null</span> = <span class="number">0</span>): <span class="title class_">TimerHandle</span> | <span class="literal">undefined</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">execute</span>(<span class="attr">state</span>: T, <span class="attr">delay</span>: <span class="built_in">number</span>): <span class="built_in">any</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">_execute</span>(<span class="attr">state</span>: T, <span class="attr">_delay</span>: <span class="built_in">number</span>): <span class="built_in">any</span> &#123;&#125;</span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来多了好多方法，我们可以先从重写的 <code>Action</code> 的 <code>schedule</code> 方法的位置开始：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Action</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">schedule</span>(state?: T, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">Subscription</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已经取消订阅了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">closed</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新参数，后面入参会替换</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到调度对应的 id</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="variable language_">this</span>.<span class="property">id</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该 Action 对应的 Scheduler 实例</span></span><br><span class="line">    <span class="keyword">const</span> scheduler = <span class="variable language_">this</span>.<span class="property">scheduler</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非第一次调度</span></span><br><span class="line">    <span class="keyword">if</span> (id != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 重新得到一个定时器 id </span></span><br><span class="line">      <span class="comment">// 这里可能会重新请求一个新的 id ，即类似调用 clearInterval 然后再调用 setInterval</span></span><br><span class="line">      <span class="comment">// 或者复用原本的 id ，因为这里我们包装的是 setInterval</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">id</span> = <span class="variable language_">this</span>.<span class="title function_">recycleAsyncId</span>(scheduler, id, delay);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调度即将开始，进入调度等待状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pending</span> = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新调度的延迟时间</span></span><br><span class="line">    <span class="comment">// 这里的 delay 放在后面更新是因为上面的 recycleAsyncId 会比较新旧的 delay 值来做一些操作</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">delay</span> = delay;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有调度的话调用 requestAsyncId 来开始调度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = <span class="variable language_">this</span>.<span class="property">id</span> ?? <span class="variable language_">this</span>.<span class="title function_">requestAsyncId</span>(scheduler, <span class="variable language_">this</span>.<span class="property">id</span>, delay);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回自身，因为自身就是一个 Subscription</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个重要的点：</p>
<ul>
<li>通过 <code>Scheduler</code> 的 <code>schedule</code> 来调用，每个 <code>Action</code> 只会执行一次，如果想获得类似 <code>setInterval</code> 的效果，需要手动在函数内部使用 <code>this.schedule</code> 来重新调用。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只执行一次</span></span><br><span class="line">asyncScheduler.<span class="title function_">schedule</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似 setInterval </span></span><br><span class="line"><span class="keyword">let</span> work;</span><br><span class="line">asyncScheduler.<span class="title function_">schedule</span>((work = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">  <span class="comment">// 手动重新调度</span></span><br><span class="line">  asyncScheduler.<span class="title function_">schedule</span>(work, <span class="number">2000</span>);</span><br><span class="line">&#125;), <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>AsyncScheduler</code> 内部中使用的是 <code>setInterval</code> 而非 <code>setTimeout</code> 作为底层实现，对此 RxJS 官方的解释是： 单个 <code>setInterval</code> 的执行间隔比起多个 <code>setTimeout</code> 的间隔更精确。</li>
</ul>
<blockquote>
<p>However, JS runtimes and timers distinguish between intervals achieved by serial <code>setTimeout</code> calls vs. a single <code>setInterval</code> call. An interval of serial <code>setTimeout</code> calls can be individually delayed, which delays scheduling the next <code>setTimeout</code>, and so on. <code>setInterval</code> attempts to guarantee the interval callback will be invoked more precisely to the interval period, regardless of load.</p>
</blockquote>
<ul>
<li>所有的 <code>Scheduler</code> 在内部都不会自动调用 <code>unsubscribe</code> 来取消自身的订阅，这是因为即使在多次的调度中，我们可能会通过额外的定时器来启动调度，比如：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asyncScheduler.<span class="title function_">schedule</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 下面的调度在一个异步的操作中</span></span><br><span class="line">  <span class="comment">// 同步的代码无法确认“未来”是否会被重新调度</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">schedule</span>(<span class="literal">undefined</span>, <span class="number">2000</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p>所以如果你只想执行单次的调度，最好在调度函数执行结束后调用 <code>unsubscribe</code> ，或者对返回的对象在合适的时机调用 <code>unsubscribe</code> ：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subscription = asyncScheduler.<span class="title function_">schedule</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 下面的调度在一个异步的操作中</span></span><br><span class="line">  <span class="comment">// 同步的代码无法确认“未来”是否会被重新调度</span></span><br><span class="line">  <span class="comment">// ... 一些操作</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">unsubscribe</span>();</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 一些操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在合适的时机取消订阅</span></span><br><span class="line">subscription.<span class="title function_">unsubscribe</span>();</span><br></pre></td></tr></table></figure>

<p>回到 <code>schedule</code> 实现中，我们发现它主要关联了两个函数，一个是 <code>requestAsyncId</code> ，一个是 <code>recycleAsyncId</code> ，根据名字我们大致可以知道， <code>requestAsyncId</code> 应该就是请求调度，然后返回一个该调度的 id ，而 <code>recycleAsyncId</code> 大致是回收一个调度，这里的回收可以是取消调度器或者让调度器继续执行（什么都不做）。</p>
<p>我们先看 <code>requestAsyncId</code> ：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Action</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">requestAsyncId</span>(<span class="attr">scheduler</span>: <span class="title class_">AsyncScheduler</span>, _id?: <span class="title class_">TimerHandle</span>, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">TimerHandle</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> intervalProvider.<span class="built_in">setInterval</span>(scheduler.<span class="property">flush</span>.<span class="title function_">bind</span>(scheduler, <span class="variable language_">this</span>), delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它调用的不是原生的 <code>setInterval</code> ，而是在一个 <code>intervalProvider</code> 对象上的 <code>setInterval</code> ，我们看一下 <code>intervalProvider</code> 的实现： </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">intervalProvider</span>: <span class="title class_">IntervalProvider</span> = &#123;</span><br><span class="line">  <span class="title function_">setInterval</span>(<span class="params"><span class="attr">handler</span>: () =&gt; <span class="built_in">void</span>, timeout?: <span class="built_in">number</span>, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; delegate &#125; = intervalProvider;</span><br><span class="line">    <span class="keyword">if</span> (delegate?.<span class="property">setInterval</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.<span class="built_in">setInterval</span>(handler, timeout, ...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setInterval</span>(handler, timeout, ...args);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">clearInterval</span>(<span class="params">handle</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; delegate &#125; = intervalProvider;</span><br><span class="line">    <span class="keyword">return</span> (delegate?.<span class="property">clearInterval</span> || <span class="built_in">clearInterval</span>)(handle <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">delegate</span>: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现默认情况下就是调用的 <code>setInterval</code> ，但是 RxJS 提供了一个 <code>delegate</code> 委派对象，我们可以通过它来覆盖默认的实现，比如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">intervalProvider.<span class="property">delegate</span> = &#123;</span><br><span class="line">  <span class="title function_">setInterval</span>(<span class="params">handler, timeout, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 在每个宏任务执行完毕后再执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setInterval</span>(<span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">handler</span>(...args)), timeout, ...args);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">clearInterval</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(handler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然很多时候我们并不会去覆盖默认的实现，所以 <code>requestAsyncId</code> 可以简单重写为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Action</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">requestAsyncId</span>(<span class="attr">scheduler</span>: <span class="title class_">AsyncScheduler</span>, _id?: <span class="title class_">TimerHandle</span>, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">TimerHandle</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setInterval</span>(scheduler.<span class="property">flush</span>.<span class="title function_">bind</span>(scheduler, <span class="variable language_">this</span>), delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它的目标调度函数是 <code>Scheduler</code> 的 <code>flush</code> ，这可能就有点让人不解了，不是说需要调度的函数保存在了 <code>Action</code> 上吗，怎么又跑去调用 <code>Scheduler</code> 的方法了，别急，我们先看 <code>recycleAsyncId</code> 是如何实现的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Action</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">recycleAsyncId</span>(<span class="attr">_scheduler</span>: <span class="title class_">AsyncScheduler</span>, id?: <span class="title class_">TimerHandle</span>, <span class="attr">delay</span>: <span class="built_in">number</span> | <span class="literal">null</span> = <span class="number">0</span>): <span class="title class_">TimerHandle</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="comment">// 复用</span></span><br><span class="line">    <span class="keyword">if</span> (delay != <span class="literal">null</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">delay</span> === delay &amp;&amp; <span class="variable language_">this</span>.<span class="property">pending</span> === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除掉</span></span><br><span class="line">    <span class="keyword">if</span> (id != <span class="literal">null</span>) &#123;</span><br><span class="line">      intervalProvider.<span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段逻辑主要包括两个部分，一个是复用定时器，即不清除定时器，另一个就是清除定时器了，在前面我们说过， <code>Action</code> 中调用 <code>work</code> 是单次的，如果需要重复调度，我们需要手动的在函数内部使用 <code>this.schedule</code> 来重新调度。在判断中我们可以知道，只要延迟时间相同，那么就不会清除掉定时器，即：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;schedule before.&quot;</span>);</span><br><span class="line">asyncScheduler.<span class="property">schedule</span>&lt;<span class="built_in">void</span>&gt;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;schedule&quot;</span>);</span><br><span class="line">  <span class="comment">// 复用调度器</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">schedule</span>(<span class="literal">undefined</span>, <span class="number">3000</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;schedule after&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>理解了这两个函数之后，我们再回到 <code>Scheduler</code> 看它的 <code>flush</code> 实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncScheduler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Scheduler</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">flush</span>(<span class="attr">action</span>: <span class="title class_">AsyncAction</span>&lt;<span class="built_in">any</span>&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; actions &#125; = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在执行调度函数中，只需放入待执行队列即可</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_active</span>) &#123;</span><br><span class="line">      actions.<span class="title function_">push</span>(action);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度完成，开始执行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">error</span>: <span class="built_in">any</span>;</span><br><span class="line">    <span class="comment">// 标志位，表示已进入执行过程</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_active</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有 actions 属性中保存的所有 Action </span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 核心，我们实际调用的是 Action 的 execute 方法</span></span><br><span class="line">      <span class="keyword">if</span> ((error = action.<span class="title function_">execute</span>(action.<span class="property">state</span>, action.<span class="property">delay</span>))) &#123;</span><br><span class="line">        <span class="comment">// 出错立即退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((action = actions.<span class="title function_">shift</span>()!));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行过程结束</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_active</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 某个 Action 报错，它后面所有的 Action 直接取消掉</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">while</span> ((action = actions.<span class="title function_">shift</span>()!)) &#123;</span><br><span class="line">        action.<span class="title function_">unsubscribe</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 抛出错误</span></span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要搞清一个点，为什么需要用 <code>actions</code> 来保存同个 <code>Action</code> 的多个实例？</p>
<p>在需要调度的函数的内部，我们可能会通过 <code>this.schedule</code> 来创建一个新的调度，在 <code>AsyncScheduler</code> 中，这个 <code>actions</code> 实际上并不会有值，因为每次我们通过 <code>this.schedule </code>创建一个新的调度的时候，它会有两种情况，复用原来的调度器或者取消原来的调度器然后再创建一个，这两种都是延迟到接下来的宏任务中执行，而 <code>flush</code> 本身是同步执行的，所以在 <code>AsyncScheduler</code> 下， <code>actions</code> 不会有值， 即下面的代码不会执行到：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncScheduler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Scheduler</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">flush</span>(<span class="attr">action</span>: <span class="title class_">AsyncAction</span>&lt;<span class="built_in">any</span>&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; actions &#125; = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不会执行到下面这个 if 内</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_active</span>) &#123;</span><br><span class="line">      actions.<span class="title function_">push</span>(action);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>AsyncScheduler</code> 中， <code>actions</code> 属性用不到，但是在 <code>AsyncScheduler</code> 派生出的几种调度器中， <code>actions</code> 属性就发挥了作用，它为多个任务在<strong>同一个调度中</strong>进行统一处理提供了代码上的能力。</p>
<p>回到 <code>flush</code> 实现，在上面我们标注了核心为执行 <code>Action</code> 的 <code>execute</code> 方法，我们看一下它的实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Action</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">execute</span>(<span class="attr">state</span>: T, <span class="attr">delay</span>: <span class="built_in">number</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">closed</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;executing a cancelled action&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度已经结束，接下来要开始执行</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pending</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 核心，执行过程</span></span><br><span class="line">    <span class="keyword">const</span> error = <span class="variable language_">this</span>.<span class="title function_">_execute</span>(state, delay);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存在错误的话返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除掉定时器</span></span><br><span class="line">    <span class="comment">// 这里就是我们前面说过的，调度器的实现是单次非循环的</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">pending</span> === <span class="literal">false</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">id</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">id</span> = <span class="variable language_">this</span>.<span class="title function_">recycleAsyncId</span>(<span class="variable language_">this</span>.<span class="property">scheduler</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码还没有接触到执行 <code>work</code> 的核心， <code>work</code> 实际上是在 <code>_execute</code> 中执行的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Action</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">_execute</span>(<span class="attr">state</span>: T, <span class="attr">_delay</span>: <span class="built_in">number</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">errored</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">errorValue</span>: <span class="built_in">any</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行了调度的函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">work</span>(state);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      errored = <span class="literal">true</span>;</span><br><span class="line">      errorValue = e ? e : <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Scheduled action threw falsy error&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误取消订阅</span></span><br><span class="line">    <span class="keyword">if</span> (errored) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">unsubscribe</span>();</span><br><span class="line">      <span class="keyword">return</span> errorValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RxJS 很多这种 <code>execute</code> 和 <code>_execute</code> 的设计，目的都是为了解耦一些操作，方便后续的子类进行重写的时候能够在最小的范围内进行。</p>
<p>到这里，我们就把 <code>AsyncScheduler</code> 的流程走完了，可能你会觉得很乱，我们可以梳理一下它的调用流程：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AsyncScheduler.schedule</span><br><span class="line">-&gt; new AsyncAction</span><br><span class="line">-&gt; AsyncAction.schedule</span><br><span class="line">-&gt; AsyncAction.requestAsyncId （开始调度，目标执行函数为 flush ，此时 pending 置为 true ）</span><br><span class="line">-&gt; AsyncScheduler.flush （调度（等待）结束，开始执行 flush ，此时 pending 置为 false ）</span><br><span class="line">-&gt; AsyncAction.execute</span><br><span class="line">-&gt; AsyncAction._execute （执行实际 work 函数的地方）</span><br></pre></td></tr></table></figure>

<p>在 Chrome 的 debug 中，我们也能清晰的看到对应的调用栈：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/Dedicatus546/image@main/2023/10/27/202310271142144.avif"></p>
<p>另外作为一个 <code>Subscription</code> ，它的 <code>unsubscribe</code> 其实并不复杂：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Action</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 没关闭过才执行一次关闭</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">closed</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; id, scheduler &#125; = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">const</span> &#123; actions &#125; = scheduler;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 清理状态</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">work</span> = <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable language_">this</span>.<span class="property">scheduler</span> = <span class="literal">null</span>!;</span><br><span class="line">      <span class="comment">// 调度的状态置为 false ，因为我们不再执行这个函数了</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">pending</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 核心，从 actions 中删除自己</span></span><br><span class="line">      <span class="comment">// 对于 AsyncAction 自身，下面这段代码不会执行到，前面我们说过 AsyncAction 并不会存储到 actions 中。</span></span><br><span class="line">      <span class="title function_">arrRemove</span>(actions, <span class="variable language_">this</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 取消掉定时器</span></span><br><span class="line">      <span class="keyword">if</span> (id != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = <span class="variable language_">this</span>.<span class="title function_">recycleAsyncId</span>(scheduler, id, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 跟之前 schedule 一样，由于 recycleAsyncId 需要判断新旧 delay ，所以放到 recycleAsyncId 后清理状态</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">delay</span> = <span class="literal">null</span>!;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 父类的实现</span></span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">unsubscribe</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>AsyncAction</code> 来说，如果已经在调度状态了，那么核心就是取消掉定时器。</p>
<h3 id="AsapScheduler-和-AsapAction"><a href="#AsapScheduler-和-AsapAction" class="headerlink" title="AsapScheduler 和 AsapAction"></a>AsapScheduler 和 AsapAction</h3><p>可能很多人和我一样，在第一次看到这个的实现的时候，一头污水， Asap ，什么意思？</p>
<p>在英文中，它是 as soon as possible 的缩写，意思是“尽可能快的”。</p>
<p>比如最近 cs2 转会期间猪猪对宝蓝被下放一事发出建议，希望有队伍能尽快签下他：</p>
<p><img data-src="https://fastly.jsdelivr.net/gh/Dedicatus546/image@main/2023/10/30/202310300947615.avif" alt="Someone sign him ASAP"></p>
<p>（PS： NIP 终于不再执着 60 万了，猪猪你也不看看宝蓝最近打的什么鬼样子，被 bench 完全不意外，意外的是竟然这么久才 bench …）</p>
<p>不要被它的名字吓到，在内部中它其实就是包装了 <code>Promise.then</code> 而已。</p>
<p>如果你懂一点浏览器宏任务微任务的八股文的话，应该就能理解 <code>Promise.then</code> 比 <code>setTimeout</code> 或者 <code>setInterval</code> 快的原因了。</p>
<p><code>AsapScheduler</code> 和 <code>AsapAction</code> 分别继承了 <code>AsyncScheduler</code> 和 <code>AsyncAction</code> ，也就是是说它们的执行流程大体是相似的。</p>
<p>我们先看下 <code>AsapScheduler</code> 如何继承 <code>AsyncScheduler</code> ：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsapScheduler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AsyncScheduler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">flush</span>(action?: <span class="title class_">AsyncAction</span>&lt;<span class="built_in">any</span>&gt;): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先不管它是如何重写 <code>flush</code> 方法的，我们再看下 <code>AsapAction</code> 是如何继承的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsapAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AsyncAction</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">protected</span> <span class="attr">scheduler</span>: <span class="title class_">AsapScheduler</span>, <span class="keyword">protected</span> <span class="attr">work</span>: (<span class="variable language_">this</span>: SchedulerAction&lt;T&gt;, state?: T) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(scheduler, work);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">requestAsyncId</span>(<span class="attr">scheduler</span>: <span class="title class_">AsapScheduler</span>, id?: <span class="title class_">TimerHandle</span>, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">TimerHandle</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">recycleAsyncId</span>(<span class="attr">scheduler</span>: <span class="title class_">AsapScheduler</span>, id?: <span class="title class_">TimerHandle</span>, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">TimerHandle</span> | <span class="literal">undefined</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到重写了 <code>requestAsyncId</code> 和 <code>recycleAsyncId</code> 方法。</p>
<p>从 <code>AsyncScheduler</code> 执行的过程，我们先看 <code>requestAsyncId</code> 的实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsapAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AsyncAction</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">requestAsyncId</span>(<span class="attr">scheduler</span>: <span class="title class_">AsapScheduler</span>, id?: <span class="title class_">TimerHandle</span>, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">TimerHandle</span> &#123;</span><br><span class="line">    <span class="comment">// 如果设定了延迟时间，那么回退到 AsyncAction</span></span><br><span class="line">    <span class="keyword">if</span> (delay !== <span class="literal">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">requestAsyncId</span>(scheduler, id, delay);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里就和 AsyncAction 显著不同了</span></span><br><span class="line">    <span class="comment">// AsyncAction 直接调用 flush ，而这里是手动 push 进 actions 中，再进行 setImmediate（默认下为 Promise.then ） 调度 </span></span><br><span class="line">    scheduler.<span class="property">actions</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="comment">// 在未处于调度过程时，启动调度，并把调度的 id 挂载到 Scheduler 的 _scheduled 属性上</span></span><br><span class="line">    <span class="comment">// 如果处于调度过程中，则复用已有的调度器 id</span></span><br><span class="line">    <span class="keyword">return</span> scheduler.<span class="property">_scheduled</span> || (scheduler.<span class="property">_scheduled</span> = immediateProvider.<span class="title function_">setImmediate</span>(scheduler.<span class="property">flush</span>.<span class="title function_">bind</span>(scheduler, <span class="literal">undefined</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的是一个 <code>setImmediate</code> 的函数，和 <code>setInterval</code> 一样， RxJS 封装了它们，并且我们也能通过 <code>delegate</code> 对象来覆盖。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// immediateProvider.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">TimerHandle</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./timerHandle&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; setImmediate, clearImmediate &#125; = <span class="title class_">Immediate</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">immediateProvider</span>: <span class="title class_">ImmediateProvider</span> = &#123;</span><br><span class="line">  <span class="comment">// When accessing the delegate, use the variable rather than `this` so that</span></span><br><span class="line">  <span class="comment">// the functions can be called without being bound to the provider.</span></span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; delegate &#125; = immediateProvider;</span><br><span class="line">    <span class="keyword">return</span> (delegate?.<span class="property">setImmediate</span> || setImmediate)(...args);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">clearImmediate</span>(<span class="params">handle</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; delegate &#125; = immediateProvider;</span><br><span class="line">    <span class="keyword">return</span> (delegate?.<span class="property">clearImmediate</span> || clearImmediate)(handle <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">delegate</span>: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Immediate.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Immediate</span> = &#123;</span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="attr">cb</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = nextHandle++;</span><br><span class="line">    activeHandles[handle] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!resolved) &#123;</span><br><span class="line">      resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    resolved.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">findAndClearHandle</span>(handle) &amp;&amp; <span class="title function_">cb</span>());</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">clearImmediate</span>(<span class="attr">handle</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="title function_">findAndClearHandle</span>(handle);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在前面我们说过， <code>AsapScheduler</code> 实际上就是封装了 <code>Promise.then</code> ， <code>Promise.then</code> 和 <code>setInterval</code> 的区别还是很大的，除了执行时机的不同之外， <code>setInterval</code> 调用之后会返回一个 id ，后面我们可以通过 <code>clearInterval</code> 来取消掉这个定时器，而 <code>Promise.then</code> 是没有这个原生的功能的，在 RxJS 中，通过计数器以及一个用来标记的字面对象来实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个 Promise.then 对应一个唯一的 id</span></span><br><span class="line"><span class="comment">// 每调用 Promise.then 就自增 nextHandle，确保 id 唯一</span></span><br><span class="line"><span class="keyword">let</span> nextHandle = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 一个 Promise 对象，用来调用 then 生成一个微任务</span></span><br><span class="line"><span class="comment">// 要注意这里是懒加载的，不然 zone.js 可能无法代理这个 Promise 对象</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">resolved</span>: <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来保存当前正在调度的 id 的状态，如果 activeHandles[id] = true 则此时调度依然存在，如果不存在则调度应该被取消，也就是不执行 Promise.then 的回调</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">activeHandles</span>: &#123; [<span class="attr">key</span>: <span class="built_in">number</span>]: <span class="built_in">any</span> &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消一个微任务</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findAndClearHandle</span>(<span class="params"><span class="attr">handle</span>: <span class="built_in">number</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (handle <span class="keyword">in</span> activeHandles) &#123;</span><br><span class="line">    <span class="keyword">delete</span> activeHandles[handle];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Immediate</span> = &#123;</span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="attr">cb</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 生成一个唯一 id</span></span><br><span class="line">    <span class="keyword">const</span> handle = nextHandle++;</span><br><span class="line">    <span class="comment">// 标记为需要调度</span></span><br><span class="line">    activeHandles[handle] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 初始化全局的 Promise 对象</span></span><br><span class="line">    <span class="keyword">if</span> (!resolved) &#123;</span><br><span class="line">      resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始调度</span></span><br><span class="line">    <span class="comment">// 核心，如果 findAndClearHandle 返回了 true ，那么才执行 cb</span></span><br><span class="line">    resolved.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">findAndClearHandle</span>(handle) &amp;&amp; <span class="title function_">cb</span>());</span><br><span class="line">    <span class="comment">// 返回 id</span></span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">clearImmediate</span>(<span class="attr">handle</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// 清除调度</span></span><br><span class="line">    <span class="title function_">findAndClearHandle</span>(handle);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原生的 <code>Promise</code> 并没有取消这一说法， <code>Promise</code> 是对“未来”的一种承诺，要么成功，要么失败， RxJS 通过一个唯一的 id 来标记一个 <code>Promise.then</code> 的回调，它的简化代码类似下面这样：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pId = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> map = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cb</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">resolved.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (map[pId]) &#123;</span><br><span class="line">    <span class="title function_">cb</span>();</span><br><span class="line">    <span class="keyword">delete</span> map[pId];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一些操作</span></span><br><span class="line"><span class="comment">// 让 cb 调度</span></span><br><span class="line">map[pId] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一些操作</span></span><br><span class="line"><span class="comment">// 不想让 cb 调度了</span></span><br><span class="line"><span class="keyword">delete</span> map[pId];</span><br></pre></td></tr></table></figure>

<p>实际上， <code>Promise.then</code> 确实执行了，但是通过包括一段对标记的判断来实现“取消”调度，实际上是没执行到调度（ <code>&amp;&amp;</code> 操作符短路了）。</p>
<p>接下来我们看一下 <code>recycleAsyncId</code> 的实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsapAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AsyncAction</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">recycleAsyncId</span>(<span class="attr">scheduler</span>: <span class="title class_">AsapScheduler</span>, id?: <span class="title class_">TimerHandle</span>, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">TimerHandle</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="comment">// 如果设定了延迟时间，那么回退到 AsyncAction</span></span><br><span class="line">    <span class="keyword">if</span> (delay != <span class="literal">null</span> ? delay &gt; <span class="number">0</span> : <span class="variable language_">this</span>.<span class="property">delay</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">recycleAsyncId</span>(scheduler, id, delay);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果已经没有任务需要执行了的话，清掉调度器的 id</span></span><br><span class="line">    <span class="comment">// 这样下一次的调度才能正确获取新的调度器 id</span></span><br><span class="line">    <span class="keyword">const</span> &#123; actions &#125; = scheduler;</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="literal">null</span> &amp;&amp; actions[actions.<span class="property">length</span> - <span class="number">1</span>]?.<span class="property">id</span> !== id) &#123;</span><br><span class="line">      immediateProvider.<span class="title function_">clearImmediate</span>(id);</span><br><span class="line">      <span class="comment">// 重要判断，由于我们会嵌套调用 schedule ，此时在执行外层 schedule 结束后我们会调用本方法来复用或者取消调度器，但是在内部执行的时候 _scheduled 就会更新成新的调度器 id 的值了，所以要判断两者是否一致，不然会导致嵌套的调度调用不全，具体可以看 https://github.com/ReactiveX/rxjs/issues/6747</span></span><br><span class="line">      <span class="keyword">if</span> (scheduler.<span class="property">_scheduled</span> === id) &#123;</span><br><span class="line">        scheduler.<span class="property">_scheduled</span> = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可能需对两个重写的函数配合起来理解。</p>
<p>在 <code>AsapScheduler</code> 中，在一次同步执行的过程中产生的新的调度都会共用一个调度器的 id ，而这个 id 挂载在父类 <code>AsyncScheduler</code> 的 <code>_schedule</code> 属性上。</p>
<p>之前我们说过 <code>AsyncScheduler</code> 中暂时使用不到 <code>_schedule</code> 属性，因为对于 <code>AsyncScheduler</code> ，每次调度都会产生新的调度器 id ，而 <code>AsapScheduler</code> 则是共用一个调度器 id ，在一次调度中对于所有嵌套的调度统一批处理。我们可以用下面的例子来解释：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动一个调度，得到一个 id = 1</span></span><br><span class="line"><span class="comment">// 放到 actions 中</span></span><br><span class="line">asapScheduler.<span class="title function_">schedule</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 启动一个调度，得到一个 id = 2</span></span><br><span class="line">  <span class="comment">// 放到 actions 中</span></span><br><span class="line">  asapScheduler.<span class="title function_">schedule</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="comment">// 放到 actions 中</span></span><br><span class="line">  <span class="comment">// 复用前面的调度 id = 2</span></span><br><span class="line">  asapScheduler.<span class="title function_">schedule</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码会输出 1 2 3 4 ，即最外层的 <code>schedule</code> 使用一次 <code>Promise.then</code> 调度，内部两个 <code>schedule</code> 使用一次 <code>Promise.then</code> ，即合并执行。</p>
<p>这也符合原生 <code>Promise.then</code> 的执行顺序，如果在一个微任务中继续启动一个微任务，那么新的微任务将会放到当前微任务的后面，在当前微任务执行完成后立即执行新的微任务，上面的写法就类似如下 <code>Promise.then</code> 的写法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p>接着我们回到 <code>AsapScheduler</code> 中，看看 <code>flush</code> 是如何重写的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsapScheduler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AsyncScheduler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">flush</span>(action?: <span class="title class_">AsyncAction</span>&lt;<span class="built_in">any</span>&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_active</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 当前的 Asap 调度器 id ，可能不存在</span></span><br><span class="line">    <span class="comment">// 如果把 AsapScheduler 当作 AsyncScheduler 使用的话，这里的 _scheduled 就不会有值</span></span><br><span class="line">    <span class="comment">// 因为我们前面说过， AsyncScheduler 的调度器 id 位于每个 Action 实例中</span></span><br><span class="line">    <span class="keyword">const</span> flushId = <span class="variable language_">this</span>.<span class="property">_scheduled</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除调度器 id ，如果调度器 id 存在，（这个调度器 id 一定是基于 Promise.then 的）那么本次的执行就会执行全部的任务</span></span><br><span class="line">    <span class="comment">// 清除掉，其他调度才能正确地通过 requestAsyncId 获取一个新的调度 id</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_scheduled</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; actions &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">error</span>: <span class="built_in">any</span>;</span><br><span class="line">    action = action || actions.<span class="title function_">shift</span>()!;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 批处理，把所有调度器 id 相同的 Action 都执行掉</span></span><br><span class="line">      <span class="keyword">if</span> ((error = action.<span class="title function_">execute</span>(action.<span class="property">state</span>, action.<span class="property">delay</span>))) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果当前处理的是 AsyncAction ，那么 while 只会执行一次，因为如果我们在一个 AsyncAction 中请求 AsapAction 的话， action.id === flushId 不成立， flushId 此时一定是 undefined 。</span></span><br><span class="line">      <span class="comment">// 而如果处理的是 AsapAction 则此时则会一次性执行掉所有存在的任务。直到某个 action 的 id 不为当前批处理的 id （比如嵌套调用的情况）。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((action = actions[<span class="number">0</span>]) &amp;&amp; action.<span class="property">id</span> === flushId &amp;&amp; actions.<span class="title function_">shift</span>());</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_active</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误情况</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">while</span> ((action = actions[<span class="number">0</span>]) &amp;&amp; action.<span class="property">id</span> === flushId &amp;&amp; actions.<span class="title function_">shift</span>()) &#123;</span><br><span class="line">        action.<span class="title function_">unsubscribe</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能你在看这个实现的时候有点晕，其实只要明白以下的两点</p>
<ul>
<li>在传入的 <code>Action</code> 是 <code>AsyncAction</code> 时，此时 <code>actions</code> 数组可能为空也可能不为空，这取决于你在传入的 <code>AsyncAction</code> 中所进行的动作，但是可以肯定的是，这个 <code>AsyncAction</code> 前面一定不会有 <code>AsapAction</code> 了，因为我们处在一个宏任务中，如果此时它的前面存在未执行的 <code>AsapAction</code> ，那么这是矛盾的，因为这些 <code>AsapAction</code> 应该在上一个微任务队列就被清空了。</li>
<li>在传入的 <code>Action</code> 是 <code>AsapAction</code> 时，此时 <code>actions</code> 可能为空也可能不为空，这取决于你在传入的 <code>AsapAction</code> 中所进行的动作。但是 <code>actions</code> 一定不会有 <code>AsyncAction</code> 实例，这是因为 <code>AsyncAction</code> 只会在 <code>flush</code> 的时候传入，并不会手动加入到 <code>actions</code> 中。</li>
</ul>
<p>这个方法其实就是兼容了 <code>AsyncScheduler</code> 的 <code>flush</code> 实现，并且额外实现了批处理本次微任务的全部 <code>Action</code> 的功能。</p>
<h3 id="AnimationFrameScheduler-和-AnimationFrameAction"><a href="#AnimationFrameScheduler-和-AnimationFrameAction" class="headerlink" title="AnimationFrameScheduler 和 AnimationFrameAction"></a>AnimationFrameScheduler 和 AnimationFrameAction</h3><p>这两者的实现和 <code>AsapScheduler</code> 和 <code>AsapAction</code> 几乎一样，唯一的区别就是从 <code>Promise.then</code> 切换到了 <code>requestAnimateFrame</code> ，所以这里就不讲了。</p>
<p>需要注意的一点是， <code>AnimationFrameScheduler</code> 似乎有个遗留的 bug ，在之前修复 <code>AsapScheduler</code> 的时候没有顺道修好像？</p>
<p>不过这也只是我的猜测，贴上相关的 <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/rxjs/issues/7196">asapScheduler: Scheduling inside of an executing action only works once</a></p>
<p>对于 <code>AnimationFrameScheduler</code> ，现在的问题是如果嵌套使用的话会导致只执行一次嵌套的调度，如下图所示：</p>
<p><img data-src="https://user-images.githubusercontent.com/48575405/279329977-5427887c-3aab-4594-aee3-b6e709336b8d.png"></p>
<p>而如果使用原生的 <code>requestAnimateFrame</code> 则没有这个问题，如下图：</p>
<p><img data-src="https://user-images.githubusercontent.com/48575405/279330102-0745fb8d-be07-44c3-a452-2699e161630d.png"></p>
<p>我也在上面的 issue 中询问了维护者，看他是怎么回复的吧。</p>
<h3 id="QueueScheduler-和-QueueAction"><a href="#QueueScheduler-和-QueueAction" class="headerlink" title="QueueScheduler 和 QueueAction"></a>QueueScheduler 和 QueueAction</h3><p><code>QueueScheduler</code> 是一种“同步”的 <code>AsapScheduler</code> ，可能这句话会让你觉得很懵逼。</p>
<p>在 <code>AsapScheduler</code> 中，我们会把任务延迟到微任务队列中执行，如果在微任务中继续启动 <code>AsapScheduler</code> 的话，那么这些任务会被放到 <code>actions</code> 属性中，然后在当前 Action 执行完毕之后，继续执行 <code>actions</code> 中的剩余 Action 。</p>
<p>而 <code>QueueScheduler</code> 则是立即执行任务，如果在执行的任务中继续调用 <code>QueueScheduler</code> ，那么会放到 <code>actions</code> 属性中，在当前 Action 执行完毕之后继续执行 <code>actions</code> 中的剩余 Action 。</p>
<p>我们可以用下面的代码来表示两者的区别：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">asapScheduler.<span class="title function_">schedule</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  asapScheduler.<span class="title function_">schedule</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  asapScheduler.<span class="title function_">schedule</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面例子输出：</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">queueScheduler.<span class="title function_">schedule</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  queueScheduler.<span class="title function_">schedule</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  queueScheduler.<span class="title function_">schedule</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面例子输出：</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// after</span></span><br></pre></td></tr></table></figure>

<p><code>QueueScheduler</code> 只是继承了 <code>AsyncScheduler</code> 而已，并没有重写什么：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">QueueScheduler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AsyncScheduler</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们的重点主要是 <code>QueueAction</code> ，它继承了 <code>AsyncAction</code> ：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">QueueAction</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AsyncAction</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">protected</span> <span class="attr">scheduler</span>: <span class="title class_">QueueScheduler</span>, <span class="keyword">protected</span> <span class="attr">work</span>: (<span class="variable language_">this</span>: SchedulerAction&lt;T&gt;, state?: T) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(scheduler, work);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">schedule</span>(state?: T, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">Subscription</span> &#123;</span><br><span class="line">    <span class="comment">// 回退到 AsyncScheduler</span></span><br><span class="line">    <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">schedule</span>(state, delay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">delay</span> = delay;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state;</span><br><span class="line">    <span class="comment">// 核心，放到 actions 属性中</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scheduler</span>.<span class="title function_">flush</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">execute</span>(<span class="attr">state</span>: T, <span class="attr">delay</span>: <span class="built_in">number</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> delay &gt; <span class="number">0</span> || <span class="variable language_">this</span>.<span class="property">closed</span></span><br><span class="line">        <span class="comment">// 回退到 AsyncScheduler</span></span><br><span class="line">      ? <span class="variable language_">super</span>.<span class="title function_">execute</span>(state, delay)</span><br><span class="line">      : <span class="variable language_">this</span>.<span class="title function_">_execute</span>(state, delay);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">requestAsyncId</span>(<span class="attr">scheduler</span>: <span class="title class_">QueueScheduler</span>, id?: <span class="title class_">TimerHandle</span>, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="title class_">TimerHandle</span> &#123;</span><br><span class="line">      <span class="comment">// 回退到 AsyncScheduler</span></span><br><span class="line">    <span class="keyword">if</span> ((delay != <span class="literal">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) || (delay == <span class="literal">null</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">delay</span> &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">requestAsyncId</span>(scheduler, id, delay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放到 actions 中</span></span><br><span class="line">    scheduler.<span class="title function_">flush</span>(<span class="variable language_">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回 0 ，并不是意味着一个调度器的 id 为 0， 而是表示调度器已被清除，这里返回 0 只是类型需要。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码我们可以知道，当我们通过 <code>queueScheduler.schedule</code> 进行调度的时候，它会同步执行到 <code>requestAsyncId</code> 方法，此时直接执行了 <code>scheduler.flush</code> ，此时会直接开始调度，而嵌套的 <code>queueScheduler.schedule</code> 调用，也会走到 <code>scheduler.flush</code> ，但是此时 <code>_active</code> 此时为 <code>true</code> ，只会把它推入到 <code>actions</code> 中，然后当第一个执行完毕之后，剩余 <code>actions</code> 内的 <code>Action</code> 就会被依次执行。</p>
<h2 id="Scheduler-和-Observable"><a href="#Scheduler-和-Observable" class="headerlink" title="Scheduler 和 Observable"></a>Scheduler 和 Observable</h2><p>对于一个 <code>Observable</code> ，有两个地方我们可以让 <code>Scheduler</code> 织入，一个是 <code>subscribe</code> 的时候，一个是 <code>next</code> （或者 <code>complete</code> 或者 <code>error</code> ） 的时候。</p>
<p>RxJS 提供了两个管道 <code>subscribeOn</code> 和 <code>observeOn</code> 来对应这两种情况。</p>
<h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h3><p><code>subscribeOn</code> 决定的是订阅操作的时机。</p>
<p>它的实现很简单，通过传入的 <code>Scheduler</code> 来启动一个调度，在调度函数的内部执行 <code>subscribe</code> 操作：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">subscribeOn</span>(<span class="params">scheduler, delay = <span class="number">0</span></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">source</span>) =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="function">(<span class="params">subscriber</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// .schedule 返回了一个 Subscription </span></span><br><span class="line">      subscriber.<span class="title function_">add</span>(scheduler.<span class="title function_">schedule</span>(<span class="function">() =&gt;</span> source.<span class="title function_">subscribe</span>(subscriber), delay));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ObserveOn"><a href="#ObserveOn" class="headerlink" title="ObserveOn"></a>ObserveOn</h3><p><code>observeOn</code> 决定的是订阅了之后发出值的时机。</p>
<p>它的实现同样不难，通过代理原来的 <code>subscriber</code> ，重写对应的三个方法来实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observeOn</span>(<span class="params">scheduler, delay = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">source</span>) =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observable</span>(<span class="function">(<span class="params">destination</span>) =&gt;</span> &#123;</span><br><span class="line">      source.<span class="title function_">subscribe</span>(</span><br><span class="line">        <span class="comment">// 之前我们写过的 operate 操作符，可以代理 subscriber ，重写方法。</span></span><br><span class="line">        <span class="title function_">operate</span>(&#123;</span><br><span class="line">          destination,</span><br><span class="line">          <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="title function_">executeSchedule</span>(destination, scheduler, <span class="function">() =&gt;</span> destination.<span class="title function_">next</span>(value), delay),</span><br><span class="line">          <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="title function_">executeSchedule</span>(destination, scheduler, <span class="function">() =&gt;</span> destination.<span class="title function_">error</span>(err), delay),</span><br><span class="line">          <span class="attr">complete</span>: <span class="function">() =&gt;</span> <span class="title function_">executeSchedule</span>(destination, scheduler, <span class="function">() =&gt;</span> destination.<span class="title function_">complete</span>(), delay),</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了 <code>executeSchedule</code> ，它的内部实现就是通过调度器来启动相应的 <code>work</code> 。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">executeSchedule</span>(<span class="params"></span></span><br><span class="line"><span class="params">  parentSubscription,</span></span><br><span class="line"><span class="params">  scheduler,</span></span><br><span class="line"><span class="params">  work,</span></span><br><span class="line"><span class="params">  delay = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">  repeat = <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 启动调度</span></span><br><span class="line">  <span class="keyword">const</span> scheduleSubscription = scheduler.<span class="title function_">schedule</span>(<span class="keyword">function</span> (<span class="params"><span class="attr">this</span>: <span class="title class_">SchedulerAction</span>&lt;<span class="built_in">any</span>&gt;</span>) &#123;</span><br><span class="line">    <span class="title function_">work</span>();</span><br><span class="line">    <span class="keyword">if</span> (repeat) &#123;</span><br><span class="line">      <span class="comment">// 这里如果是同步的调度器，那么我们需要手动添加</span></span><br><span class="line">      parentSubscription.<span class="title function_">add</span>(<span class="variable language_">this</span>.<span class="title function_">schedule</span>(<span class="literal">null</span>, delay));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这里的 observeOn 只会走到这里</span></span><br><span class="line">      <span class="comment">// 执行一次之后不再执行，需要手动取消订阅</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">unsubscribe</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, delay);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加，即使重复添加也没有关系，因为 Subscription 是通过 Set 来保存这些 Subscription 的</span></span><br><span class="line">  parentSubscription.<span class="title function_">add</span>(scheduleSubscription);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个返回我们在 observeOn 不会用到所以不管。</span></span><br><span class="line">  <span class="keyword">if</span> (!repeat) &#123;</span><br><span class="line">    <span class="keyword">return</span> scheduleSubscription;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他操作符和管道"><a href="#其他操作符和管道" class="headerlink" title="其他操作符和管道"></a>其他操作符和管道</h3><p>在 RxJS 中，虽然很多时候我们不会明显的使用到 <code>Scheduler</code> ，但是某些操作符或者管道默认情况下都是可以通过最后一个入参来控制，比如 <code>delay</code> 管道，在默认情况下它会使用 <code>asyncScheduler</code> 作为调度器：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> delay&lt;T&gt;(</span><br><span class="line">  <span class="attr">due</span>: <span class="built_in">number</span> | <span class="title class_">Date</span>, </span><br><span class="line">  <span class="comment">// 默认调度器</span></span><br><span class="line">  <span class="attr">scheduler</span>: <span class="title class_">SchedulerLike</span> = asyncScheduler</span><br><span class="line">): <span class="title class_">MonoTypeOperatorFunction</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> duration = <span class="title function_">timer</span>(due, scheduler);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">delayWhen</span>(<span class="function">() =&gt;</span> duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>在逛 issue 的时候，发现了作者说在 8.0 可能会发布一个更加轻巧的调度器，说实话，作为一个切图仔，我还是不是很喜欢继承，这东西对脑的算力有点高，恰好我的🧠又很一般，方法跳来跳去，很容易就阅读疲劳，每次调用方法都得思考它的子类是不是重写了，他这段逻辑是不是只对子类有作用的？</p>
<p>而且我总觉得这个调度器的继承关系有点让人懵逼，作为基类的 <code>AsyncScheduler</code> 竟然会有 <code>_schedule</code> 这种子类才要用到的属性… 当然，这里只是小小的吐槽，咱也不是什么 OOP 高手，而且写代码有时候真的不是那样一定对这样一定错，有可能在某些情况下必须写成错的方式才能好处理，所以保持谦虚，不要妄自菲薄。</p>
<p>在逛 issue 的时候，发现有人抱怨作者维护的太慢了，作者回了句：</p>
<blockquote>
<p>A friendly reminder to some of the snark in here: This is free software maintained by unpaid volunteers. I understand you’re frustrated, but I’m quite literally not paid to deal with you.</p>
</blockquote>
<p>大意就是“免费软件，我没空修你得等着，抱怨是没用的”。 我还是很支持作者的，选择开源软件，你就应该明白，免费的往往就是最贵的，大家可以为爱发电，也可以立马崩撤卖溜。不过 RxJS 作为 Angular 的一个重要的依赖库（另一个应该是 zone.js ），它的稳定还是很重要的，虽然国内 Angular 开发者可能并不多。</p>
<p>RxJS 的源码部分应该就到这里了，在大半年前，我发了几篇关于 RxJS 使用的帖子，而现在，我发了关于 RxJS 的几篇源码解析的文章。当然我写的可能会有错误，可能写的不能让所有对 RxJS 感兴趣的人明白它的内部实现，但如果有某个人了解了，领悟了，那么我的价值就实现了。如果你发现帖子中有任何代码错误，逻辑错误，书写错误的问题，可以通过下面的评论来反馈，非常感谢！</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Dedicatus545
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://prohibitorum.top/7f3585880481" title="RxJS 源码解读之 Scheduler">https://prohibitorum.top/7f3585880481</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
              <a href="/tags/RxJS/" rel="tag"># RxJS</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/58091f9cefdf" rel="prev" title="RxJS 源码解读之派生 Subject">
                  <i class="fa fa-angle-left"></i> RxJS 源码解读之派生 Subject
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/d8804bf6ed5f" rel="next" title="TypeScript 5.3（译）">
                  TypeScript 5.3（译） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Dedicatus545</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">425k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">25:45</span>
  </span>
</div>

<div class="site_sign">
  <span class="post-meta-item">
    <span>
      如果我和狗一样有尾巴的话，一定会藏不住这份喜悦，而尾巴一直摇个不停吧。
    </span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://fastly.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://fastly.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://fastly.jsdelivr.net/npm/algoliasearch@4.23.3/dist/algoliasearch-lite.umd.js" integrity="sha256-1QNshz86RqXe/qsCBldsUu13eAX6n/O98uubKQs87UI=" crossorigin="anonymous"></script>
<script src="https://fastly.jsdelivr.net/npm/instantsearch.js@4.67.0/dist/instantsearch.production.min.js" integrity="sha256-TW7D3X/i/W+RUgEeDppEnFT2ixv5lzplKH0c58D92dY=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"Dedicatus546","repo":"gitalk","client_id":"f7dc1ebbf18fc0fd3a5c","client_secret":"0893318788a1b62f883bdace8c12e6c42d76b402","admin_user":"Dedicatus546","distraction_free_mode":true,"proxy":"https://strong-caramel-969805.netlify.app/github_access_token","language":"zh-CN","js":{"url":"https://fastly.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"1698316019"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

<!-- hexo injector body_end start -->
<script src="https://cdn.jsdelivr.net/npm/swiper@11.1.9/swiper-bundle.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11.1.9/swiper-bundle.min.css">
<style>
    :root {
      --swiper-theme-color: var(--theme-color);
      --swiper-pagination-bottom: 0;
    }
    .swiper {
      padding-bottom: 32px;
      margin-bottom: 20px;
    }
    .swiper .swiper-slide .swiper-slide-img {
      display: block;
      width: 100%;
      object-fit: contain;
      background: var(--body-bg-color);
      margin: 0;
    }
  </style><!-- hexo injector body_end end --></body>
</html>
